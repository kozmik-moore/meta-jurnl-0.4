"""Functions for querying the database for general information"""
from contextlib import closing
from datetime import datetime
from sqlite3 import connect, Connection
from typing import Union, List

from database import default_database


def get_all_entry_ids(connection: Connection):
    t = connection.execute('SELECT entry_id FROM dates ORDER BY created').fetchall()
    return [x[0] for x in t]


def get_all_tags(database: str = None):
    """Gets all tags in the database

    :rtype: list
    :param database: a str representing the database that is being queried
    :return: a list of str representing all tags used in the database
    """
    db = connect(database) if database else connect(default_database())
    with closing(db) as d:
        t = set(d.execute('SELECT tag FROM tags ORDER BY tag').fetchall())
        return [x[0] for x in t]


def get_all_creation_dates(connection: Connection) -> List[datetime]:
    dates = [x[0] for x in connection.execute('SELECT created FROM dates ORDER BY created').fetchall()]
    dates.sort()
    return dates


def get_all_edit_dates(connection: Connection) -> List[datetime]:
    dates = [x[0] for x in connection.execute('SELECT last_edit FROM dates ORDER BY created').fetchall()]
    dates.sort()
    return dates


def get_all_access_dates(connection: Connection) -> List[datetime]:
    dates = [x[0] for x in connection.execute('SELECT last_access FROM dates ORDER BY created').fetchall()]
    dates.sort()
    return dates


def get_oldest_date(connection: Connection, date_type: str = 'creation') -> Union[datetime, None]:
    try:
        if date_type == 'creation':
            return get_all_creation_dates(connection)[0]
        elif date_type == 'edit':
            return get_all_edit_dates(connection)[0]
        elif date_type == 'access':
            return get_all_access_dates(connection)[0]
    except IndexError:
        return None


def get_newest_date(connection: Connection, date_type: str = 'creation') -> Union[datetime, None]:
    try:
        if date_type == 'creation':
            return get_all_creation_dates(connection)[-1]
        elif date_type == 'edit':
            return get_all_edit_dates(connection)[-1]
        elif date_type == 'access':
            return get_all_access_dates(connection)[-1]
    except IndexError:
        return None


def get_all_children(database: str = None):
    """Gets the ids of all entries that were generated by another entry

    :rtype: list
    :param database: a Connection or str representing the database that is being queried
    :return: a list of ints representing entries
    """
    db = connect(database) if database else connect(default_database())
    with closing(db) as d:
        return [x[0] for x in d.execute('SELECT child from relations').fetchall()]


def get_all_parents(database: str = None):
    """Gets the ids of all entries that have generated another entry

    :rtype: list
    :param database: a Connection or str representing the database that is being queried
    :return: a list of ints representing entries
    """
    db = connect(database) if database else connect(default_database())
    with closing(db) as d:
        return [x[0] for x in d.execute('SELECT parent from relations').fetchall()]


def get_all_relations(database: str = None):
    """Gets all relation pairs from the database

    :rtype: tuple
    :param database: a Connection or str representing the database that is being queried
    :return: a collection of linked pairs, each representing a parent-child relationship
    """
    db = connect(database) if database else connect(default_database())
    with closing(db) as d:
        pairs = d.execute('SELECT child,parent FROM relations')
    return pairs


def get_number_of_entries(database: str = None):
    """Counts the number of entries in the database.

    :rtype: int
    :param database: a Connection or str representing the database that is being queried
    :return: an int representing the number of entries in the database
    """
    db = connect(database) if database else connect(default_database())
    with closing(db) as d:
        count = d.execute('SELECT COUNT() FROM bodies').fetchone()[0]
    return count


def get_years(database: str = None):
    """Lists, in order, the years in which the database has entries

    :rtype: list
    :param database: a Connection or str representing the database that is being queried
    :return: a list representing the years in which the database has entries
    """
    db = connect(database) if database else connect(default_database())
    with closing(db) as d:
        years = list({x[0] for x in d.execute('SELECT year FROM dates')})
        years.sort()
    return years


def database_is_empty(database: str = None):
    if len(get_all_entry_ids(database if database else default_database())) == 0:
        return True
    else:
        return False


def close_connection(database: Connection):
    """Closes the connection to the database

    :param database: a Connection or str representing the database that is being queried
    """
    database.close()
